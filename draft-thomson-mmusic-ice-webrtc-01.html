<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Using Interactive Connectivity Establishment (ICE) in Web Real-Time Communications (WebRTC) </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style><style tyle="text/css">body {   font: 11pt cambria, helvetica, arial, sans-serif;   font-size-adjust: 0.5;   line-height: 130%;   margin: 1em auto;   max-width: 700px; }  .title, .filename, h1, h2, h3, h4 {   font-family: candara, helvetica, arial, sans-serif;   font-size-adjust: 0.5; } .title { font-size: 150%; } h1 { font-size: 130%; } h2 { font-size: 120%; } h3, h4 { font-size: 110%; } ul.toc >li { font-size: 95%; } ul.toc >li >ul, .figure, caption { font-size: 90%; }  table {   margin-left: 0em; } table.header {   width: 100%; }  table.header td {   background-color: inherit;   color: black; }  samp, tt, code, pre {   font: 11pt consolas, monospace;   font-size-adjust: none; }  pre.text, pre.text2 {   width: 90%; }  dt {   float: left; clear: left;   margin: 0.5em 0.5em 0 0; } dt:first-child {   margin-top: 0; } dd {   margin: 0.5em 0 0 2em; } dd p, dd ul {   margin-top: 0; margin-bottom: 0; } dd *+p {   margin-top: 0.5em; }  ol, ul {   padding: 0;   margin: 0.5em 0 0.5em 2em; } ul.toc, ul.toc ul {    margin: 0 0 0 1.5em; } ul.toc a:first-child {    display: inline-block;    min-width: 1.2em; }</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Conventions and Terminology"/>
<link href="#rfc.section.2" rel="Chapter" title="2 ICE in a Web Browser"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Factors Influencing DoS Capacity"/>
<link href="#rfc.section.2.1.1" rel="Chapter" title="2.1.1 Pacing of Connectivity Checks"/>
<link href="#rfc.section.2.1.2" rel="Chapter" title="2.1.2 Retransmission of Connectivity Checks"/>
<link href="#rfc.section.2.1.3" rel="Chapter" title="2.1.3 Connectivity Check Size"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Denial of Service Magnitude"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Modified ICE Algorithm"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Trickled and Peer Reflexive Candidates"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Multiple ICE Agents"/>
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Introducing Artificial Contention"/>
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 Origin-First Round-Robin"/>
<link href="#rfc.section.3.2.3" rel="Chapter" title="3.2.3 Inter-Agent Candidate Pair Freezing"/>
<link href="#rfc.section.3.2.4" rel="Chapter" title="3.2.4 Delayed ICE Agent Start"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Further Reducing the Impact of Attacks"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Bandwidth Rate Limiting"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Malicious Application Penalties"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Limited Concurrent Access to ICE"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Negotiating Algorithm Use"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="8 References"/>
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Defining Legitimate Uses of ICE"/>
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Candidate Pair Count"/>
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Connectivity Check Size"/>
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 Rate Calculations"/>
<link href="#rfc.appendix.A.4" rel="Chapter" title="A.4 Comparison: G.711 Audio"/>
<link href="#rfc.appendix.A.5" rel="Chapter" title="A.5 Recommended Rate Limits"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.4.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Thomson, M." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-thomson-mmusic-ice-webrtc-01" />
  <meta name="dct.issued" scheme="ISO8601" content="2013-11-04" />
  <meta name="dct.abstract" content="Interactive Connectivity Establishment (ICE) has been selected as the basis for establishing peer-to-peer UDP flows between Web Real-Time Communication (WebRTC) clients.  Using an unmodified ICE implementation in this context enables the use of the web platform as a denial of service platform.  The risks and complications arising from this choice are discussed.  A modified algorithm for sending ICE connectivity checks from the web platform is described.  " />
  <meta name="description" content="Interactive Connectivity Establishment (ICE) has been selected as the basis for establishing peer-to-peer UDP flows between Web Real-Time Communication (WebRTC) clients.  Using an unmodified ICE implementation in this context enables the use of the web platform as a denial of service platform.  The risks and complications arising from this choice are discussed.  A modified algorithm for sending ICE connectivity checks from the web platform is described.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">MMUSIC</td>
  <td class="right">M. Thomson</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Microsoft</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">November 04, 2013</td>
</tr>
<tr>
  <td class="left">Expires: May 08, 2014</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Using Interactive Connectivity Establishment (ICE) in Web Real-Time Communications (WebRTC) <br />
  <span class="filename">draft-thomson-mmusic-ice-webrtc-01</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>Interactive Connectivity Establishment (ICE) has been selected as the basis for establishing peer-to-peer UDP flows between Web Real-Time Communication (WebRTC) clients.  Using an unmodified ICE implementation in this context enables the use of the web platform as a denial of service platform.  The risks and complications arising from this choice are discussed.  A modified algorithm for sending ICE connectivity checks from the web platform is described.  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 08, 2014.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2013 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>1.1.   <a href="#rfc.section.1.1">Conventions and Terminology</a></li>
<li>2.   <a href="#rfc.section.2">ICE in a Web Browser</a></li>
<li>2.1.   <a href="#rfc.section.2.1">Factors Influencing DoS Capacity</a></li>
<li>2.1.1.   <a href="#rfc.section.2.1.1">Pacing of Connectivity Checks</a></li>
<li>2.1.2.   <a href="#rfc.section.2.1.2">Retransmission of Connectivity Checks</a></li>
<li>2.1.3.   <a href="#rfc.section.2.1.3">Connectivity Check Size</a></li>
<li>2.2.   <a href="#rfc.section.2.2">Denial of Service Magnitude</a></li>
<li>3.   <a href="#rfc.section.3">Modified ICE Algorithm</a></li>
<li>3.1.   <a href="#rfc.section.3.1">Trickled and Peer Reflexive Candidates</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Multiple ICE Agents</a></li>
<li>3.2.1.   <a href="#rfc.section.3.2.1">Introducing Artificial Contention</a></li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">Origin-First Round-Robin</a></li>
<li>3.2.3.   <a href="#rfc.section.3.2.3">Inter-Agent Candidate Pair Freezing</a></li>
<li>3.2.4.   <a href="#rfc.section.3.2.4">Delayed ICE Agent Start</a></li>
<li>4.   <a href="#rfc.section.4">Further Reducing the Impact of Attacks</a></li>
<li>4.1.   <a href="#rfc.section.4.1">Bandwidth Rate Limiting</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Malicious Application Penalties</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Limited Concurrent Access to ICE</a></li>
<li>5.   <a href="#rfc.section.5">Negotiating Algorithm Use</a></li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a></li>
<li>7.   <a href="#rfc.section.7">Acknowledgements</a></li>
<li>8.   <a href="#rfc.references">References</a></li>
<li>8.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a></li>
<li>Appendix A.   <a href="#rfc.appendix.A">Defining Legitimate Uses of ICE</a></li>
<li>A.1.   <a href="#rfc.appendix.A.1">Candidate Pair Count</a></li>
<li>A.2.   <a href="#rfc.appendix.A.2">Connectivity Check Size</a></li>
<li>A.3.   <a href="#rfc.appendix.A.3">Rate Calculations</a></li>
<li>A.4.   <a href="#rfc.appendix.A.4">Comparison: G.711 Audio</a></li>
<li>A.5.   <a href="#rfc.appendix.A.5">Recommended Rate Limits</a></li>
<li><a href="#rfc.authors">Author's Address</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a></h1>
<p><a href="#RFC5245">ICE</a> <cite title="NONE">[RFC5245]</cite> describes a process whereby peers establish a bi-directional UDP flow.  This process has been adopted for use in Web Real-Time Communications (WebRTC) for establishing flows to and from web browsers (<a href="#I-D.ietf-rtcweb-overview">[I-D.ietf-rtcweb-overview]</a>).  </p>
<p id="rfc.section.1.p.2">Properties of ICE are also critical to the security of WebRTC (see Section 4.2.1 of <a href="#I-D.ietf-rtcweb-security">[I-D.ietf-rtcweb-security]</a>).  </p>
<p id="rfc.section.1.p.3">The design of RFC 5245 does not fully consider the threat models enabled by the web environment.  In particular, the following assumptions are not valid in a web context: </p>

<ul>
  <li>A one-time consent to communicate is sufficient, and revocation of consent is not necessary.  </li>
  <li>Signaling and control originates from actors that always operate in good faith.  </li>
  <li>Only one ICE processing context operates at the one time.  </li>
</ul>

<p> Implementations of ICE that are technically compliant with the algorithm described in RFC 5245 potentially expose controls to web applications that can be exploited.  </p>
<p id="rfc.section.1.p.4">In the web context, an attacker is able to provide code (usually JavaScript) that is executed by those hosts in a sandbox.  The protections of the sandbox are critical, both for protecting the host running the sandbox, and for protecting the Internet as a whole from bad actors.  </p>
<p id="rfc.section.1.p.5">The exposure of ICE features in the web browser could allow attackers to generate denial of service (DoS) traffic far in excess of the bandwidth needed to deploy the JavaScript.  A small (1KB) file can potentially generate many megabytes of connectivity checks in a short period, representing an amplication factor far greater than other similar amplification attacks (for instance, DNS reflection attacks).  </p>
<p id="rfc.section.1.p.6">Mounting this sort of DoS attack does not rely on anything other than inducing a host to download and execute JavaScript.  This is generally very easy to accomplish, making it very easy to conscript large number of traffic sources.  </p>
<p id="rfc.section.1.p.7">The issue regarding the one-time consent to communicate has already been identified as a serious problem for WebRTC.  <a href="#I-D.muthu-behave-consent-freshness">[I-D.muthu-behave-consent-freshness]</a> describes a limit on the time that consent remains valid, requiring that communications consent be continuously refreshed.  </p>
<p id="rfc.section.1.p.8">This document first describes the characteristics of ICE as they relate to the web and the way that these characteristics can be exploited.  In order to address the issues arising from allowing web application to initiate and control ICE processing, a modified algorithm is described, plus additional measures that can be employed to reduce the amount of traffic an attacker can produce.  </p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#terminology" id="terminology">Conventions and Terminology</a></h1>
<p id="rfc.section.1.1.p.1">In cases where normative language needs to be emphasized, this document falls back on established shorthands for expressing interoperability requirements on implementations: the capitalized words "MUST", "MUST NOT", "SHOULD" and "MAY".  The meaning of these is described in <a href="#RFC2119">[RFC2119]</a>.  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> ICE in a Web Browser</h1>
<p id="rfc.section.2.p.1">A web browser provides an API that applications can use to instantiate and control an ICE agent.  The web application is responsible for providing the ICE agent with signaling that it might need to operate successfully, as well as configuration information regarding <a href="#RFC5766">TURN</a> <cite title="NONE">[RFC5766]</cite> or <a href="#RFC5389">STUN</a> <cite title="NONE">[RFC5389]</cite> servers.  </p>
<p id="rfc.section.2.p.2">In the web context, a browser treats the web application as being potentially hostile, providing access to features in a controlled fashion.  Therefore, some of the information that an ICE agent might depend on in other contexts has to be regarded as potentially suspect when provided by a web application.  </p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> Factors Influencing DoS Capacity</h1>
<p id="rfc.section.2.1.p.1">There are several parameters that affect the characteristics of DoS attacks that can be mounted using ICE.  These include: </p>

<ul>
  <li>The number of candidate pairs that are created.  An attacker can add extra remote candidates to inflate this number to tbe maximum supported.  RFC 5245 recommends a default maximum of 100 candidate pairs.  Reducing this limit directly reduces DoS potential, though it could affect success in some legitimate scenarios (see the calculations in <a href="#ratecalc">Appendix A</a>).  </li>
  <li>The time between consecutive connectivity checks.  Pacing of checks is discussed at length in <a href="#pacing">Section 2.1.1</a>.  </li>
  <li>The total number and timing of retransmissions for each candidate pair.  <a href="#retransmission">Section 2.1.2</a> discusses the implications of retransmissions.  </li>
  <li>The size of connectivity check packets.  Size considerations are described in <a href="#size">Section 2.1.3</a>.  </li>
  <li>The number of ICE agents that can be operated concurrently.  RFC 5245 does not consider scenarios like WebRTC where it is not only possible for there to be multiple agents.  The web security model allows for cases where multiple agents can be created concurrently, often with a further restriction that a browser not leak information between agents.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1.</a> <a href="#pacing" id="pacing">Pacing of Connectivity Checks</a></h1>
<p><a href="#RFC5245">ICE</a> <cite title="NONE">[RFC5245]</cite> describes a scheme for pacing connectivity checks.  There are two primary reasons that are cited: </p>

<ul>
  <li>Pacing the initial connectivity checks for a given candidate pair allows middleboxes sufficient time to establish bindings.  Empirical evidence suggests that failing to allow at least 20 milliseconds between initial connectivity checks risks the bindings being dropped at some middleboxes.  </li>
  <li>Pacing limits the potential for connectivity checks to generate network congestion. Section 16.1 of <a href="#RFC5245">[RFC5245]</a> describes a formula for calculating the time between connectivity checks (Ta) that is based on the expected bandwidth of the real-time session that is being established.  </li>
</ul>

<p> </p>
<p id="rfc.section.2.1.1.p.2">In the web context, information about the expected bandwidth used by the session comes from the web application.  Since the web application has to be regarded as potentially malicious, information about expected media bandwidth cannot be used to determine the pacing of connectivity checks.  A fixed minimum interval between connectivity checks becomes the primary mechanism for limiting the ability of web applications to generate packets that are potentially congestion inducing.  </p>
<p id="rfc.section.2.1.1.p.3">Increasing the pacing interval directly reduces the amount of congestion that connectivity checks can generate, though this only reduces the peak bitrate that can be induced - the same amount of traffic is generated over a longer period.  The cost of this is extended session setup times, where recent efforts have been focused on reducing this time.  </p>
<h1 id="rfc.section.2.1.2"><a href="#rfc.section.2.1.2">2.1.2.</a> <a href="#retransmission" id="retransmission">Retransmission of Connectivity Checks</a></h1>
<p id="rfc.section.2.1.2.p.1">The initial retransmission timer (RTO) can also be increased with similar effect to increasing the pacing timer.  Furthermore, there is a strong desire to reduce the recommended value of the RTO in ICE from 500 milliseconds to values more reflective of common round trip times in well-connected locations, which might be as low as 50 milliseconds.  </p>
<p id="rfc.section.2.1.2.p.2">More relevant is the total number of connectivity check retransmissions that an implementation attempts for each candidate pair.  Each additional retransmission directly increases the duration and magnitude of a DoS attack.  Following the exponential backoff recommended by RFC 5245 does extend the time between retransmissions, which could reduce the rate of connectivity checks after several retransmissions, but this depends on the initial retransmission time out (RTO).  </p>
<p id="rfc.section.2.1.2.p.3">Reducing the number of retransmissions has the effect of reducing the probability of the check succeeding.  The selection of a total retransmission count is a trade-off of success rates against the potential for abuse.  </p>
<h1 id="rfc.section.2.1.3"><a href="#rfc.section.2.1.3">2.1.3.</a> <a href="#size" id="size">Connectivity Check Size</a></h1>
<p id="rfc.section.2.1.3.p.1">As currently specified, an attacker is only able to influence the size of the USERNAME attribute.  <a href="#RFC5389">[RFC5389]</a> restricts USERNAME to a maximum size of 512 octets; the Session Description Protocol (SDP) signaling described in <a href="#RFC5245">[RFC5245]</a> limits the size of the username fragment an attacker can set to 256 bytes.  </p>
<p id="rfc.section.2.1.3.p.2">A browser could reduce its username fragment to as little as 4 bytes, limiting the overall size of the attribute to 261 bytes.  A small username fragment does limit the collision resilience of the field, which is a property that is important for detecting other forms of attack (see Section 5.7.3 of <a href="#I-D.ietf-rtcweb-security-arch">[I-D.ietf-rtcweb-security-arch]</a>).  </p>
<p id="rfc.section.2.1.3.p.3">There is also the potential for new modifications to ICE that increase the packet size.  For instance <a href="#I-D.martinsen-mmusic-malice">[I-D.martinsen-mmusic-malice]</a> provides an attacker with direct control over the bytes that are included in connectivity checks.  </p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> Denial of Service Magnitude</h1>
<p id="rfc.section.2.2.p.1">A malicious application is able to influence connectivity checking by altering the set of remote candidates and by changing the remote username fragment.  The default maximum sizes for remote username fragment (256 bytes) and number of candidate pairs (100) described in RFC 5245 can be exploited by an attacker to increase the number and size of packets.  Assuming an inter-check timer of the minimum of 20 milliseconds, plus a minimal 28 bytes of IPv4 and UDP overhead, this results in an attacker being able to induce approximately 144kbps for every ICE agent it is able to instantiate.  </p>
<p id="rfc.section.2.2.p.2">This rate is significantly higher than the minimal rate of 20kbps that a typical compressed voice stream generates.  By comparison, a G.711 audio stream, which cannot be rate limited in response to network congestion, but is generally regarded as safe to send to a willing target, generates about 74kbps.  </p>
<p id="rfc.section.2.2.p.3">ICE does not allow for any congestion feedback (other than <a href="#RFC3168">ECN</a> <cite title="NONE">[RFC3168]</cite>), so this rate could conceivably be sustained for some time, though after several seconds the time between retries increases, reducing the check rate unless the application is able to instantiate another ICE agent.  </p>
<p id="rfc.section.2.2.p.4">Some existing ICE implementations could generate about 3 or more times the basic rate of connectivity checks over a short period.  These implementations do not pace retransmission of connectivity checks, resulting in significantly higher connectivity check rates during early rounds of retransmission.  </p>
<p/>

<ul class="empty">
  <li>These implementations are ignoring the advice on calculating a minimum RTO from Section 16.1 of <a href="#RFC5245">[RFC5245]</a>.  However, the shorter RTO allows ICE to complete much faster, which is a significant advantage.  </li>
</ul>

<p> </p>
<p id="rfc.section.2.2.p.6">Implementations that do not limit the number of ICE agents that can be instantiated, and subsequently fail to enforce rate limits globally create a further multiplicative factor on the basic rate.  </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#algorithm" id="algorithm">Modified ICE Algorithm</a></h1>
<p id="rfc.section.3.p.1">This section describes an algorithm that ensures proper global pacing of connectivity checks.  This limits the ability of any single attacker to generate a high rate of connectivity checks.  This only limits the peak data rate that results from connectivity checks, reducing the intensity of DoS attacks.  </p>
<p id="rfc.section.3.p.2">Measures that reduce the overall duration of attacks are described in <a href="#duration">Section 4</a>.  </p>
<p id="rfc.section.3.p.3">The modified algorithm for ICE does not alter the way that candidate pairs are selected, prioritized, frozen or signaled.  It only affects the generation of connectivity checks.  This algorithm affects candidate pairs in either of the "Waiting" or "In-Progress" states only (see Section 5.7.4 of <a href="#RFC5245">[RFC5245]</a>).  </p>
<p id="rfc.section.3.p.4">The ICE agent maintains two queues for candidate pairs.  </p>

<dl>
  <dt>waiting queue:</dt>
  <dd style="margin-left: 8">The first is a prioritized list of candidate pairs in the "Waiting" state.  The waiting queue is simply a prioritized list of all the candidate pairs in the check list (see Section 5.7 of <a href="#RFC5245">[RFC5245]</a>) that are in the "Waiting" state.  As candidate pairs enter the "Waiting" state, they are added to the waiting queue.  As each candidate pair is added, it is prioritized relative to all the other candidate pairs in the waiting queue.  </dd>
  <dt>check queue:</dt>
  <dd style="margin-left: 8">The second is for outstanding connectivity checks.  Each entry in this list represents a connectivity check for a given candidate pair.  Each entry also includes a counter representing the number of connectivity checks that have been sent on this candidate pair.  </dd>
</dl>

<p> </p>
<p id="rfc.section.3.p.5">The ICE agent maintains two types of timer: a pacing timer and a retransmission timer.  There is only one pacing timer, though there can be multiple retransmission timers running concurrently.  </p>
<p id="rfc.section.3.p.6">The first candidate pair that arrives in the waiting queue starts the pacing timer.  The pacing timer runs as long as there are items in any queue, ending if the timer expires when there are no entries in either queue.  The pacing timer resumes if an entry is added to either queue and the timer is not already running.  </p>
<p id="rfc.section.3.p.7">Each time the pacing timer expires, the ICE agent performs the following steps: </p>

<ol>
  <li>If there are items on the waiting queue, but no items on the check queue, the first candidate pair is taken from the waiting queue.  <ol style="list-style-type: lower-alpha"><li>The candidate pair transitions from "Waiting" to "In-Progress".  </li><li>A check counter is associted with the candidate pair, initialized with a zero value.  </li><li>The candidate pair is added to the check queue.  This could result in a connectivity check being sent immediately if the check queue is currently empty.  </li></ol><p> </p></li>
  <li>If there are items in the check queue, the ICE agent removes the first item and performs a connectivity check on the identified candidate pair.  <ol style="list-style-type: lower-alpha"><li>The check counter associated with the candidate pair is incremented by one.  </li><li>Based on the value of the check counter, a retransmission timer is scheduled for the candidate pair.  The retransmission timer is not scheduled if the check counter exceeds the maximum number of checks configured for the ICE agent.  </li><li>If the retransmission timer expires without the connectivity check succeeding, the candidate pair is returned to the end of the check queue along with the higher check counter.  </li><li>The retransmission timer is cancelled if the connectivity check succeeds.  The process for handling successful checks in Section 7.1.3.2 of <a href="#RFC5245">[RFC5245]</a> is followed.  </li></ol><p> </p></li>
  <li>If no connectivity checks were sent, the pacing timer is stopped.  </li>
</ol>

<p> </p>
<p id="rfc.section.3.p.8">An important characteristic of this algorithm is that it - as much as possible - prefers retransmission of connectivity checks over the initiation of new connectivity checks.  This ensures that once an initial connectivity check has established any necessary middlebox bindings, subsequent retries are not delayed excessively, which could cause the binding to time out.  However, the global pacing can cause the time between retransmission of connectivity checks to be extended as the check queue occasionally fills.  </p>
<p id="rfc.section.3.p.9">Favoring retransmission over initial checks directly contradicts the guidance on RTO selection in Section 16.1 of <a href="#RFC5245">[RFC5245]</a>.  This is necessary due to the delays induced by potential interactions between multiple ICE agents, which might otherwise cause retries to be significantly delayed.  Improvements to candidate prioritization are expected to reduce the impact of this change.  </p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> Trickled and Peer Reflexive Candidates</h1>
<p><a href="#I-D.ivov-mmusic-trickle-ice">Trickled ICE candidates</a> <cite title="NONE">[I-D.ivov-mmusic-trickle-ice]</cite> generate candidate pairs after connectivity checking has commenced.  In order to avoid trickled candidates negatively affecting the chances of a connectivity check succeeding, connectivity checks on newly appearing candidate pairs must be prioritized below any existing connectivity check.  </p>
<p id="rfc.section.3.1.p.2">Trickled candidates are in many respects identical to peer reflexive candidates.  Both arrive after the algorithm has commenced.  </p>
<p id="rfc.section.3.1.p.3">In either case, as new candidates arrive (or are discovered), they are paired as normal (Section 5.7.1 of <a href="#RFC5245">[RFC5245]</a>), and - if appropriate - entered into the "Waiting" state.  This causes the candidate pair to enter the waiting queue.  Candidate pairs in the waiting queue are not ordered based on arrival time, they are ordered based on priority alone.  </p>
<p id="rfc.section.3.1.p.4">Trickling regular candidates does introduce the potential for a mismatch in the ordering of candidate pairs between peers, since trickled candidates will appear in the sending side well before the receiving side can act upon them, resulting in the sending peer potentially commencing checks much earlier than the receiving peer.  This is particularly important given the possibility that retransmissions of connectivity checks can block the progress of a candidate pair from the "Waiting" state into the "In-Progress" state, resulting in potentially large differences in the commencement time for any given candidate pair.  </p>
<p id="rfc.section.3.1.p.5">A trickle ICE implementation MAY choose not to immediately enqueue local candidates as they are discovered to allow some time for trickle signaling to propagate in order to increase the probability that checks remain synchronized.  </p>

<ul class="empty">
  <li/>
</ul>

<p> </p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> Multiple ICE Agents</h1>
<p id="rfc.section.3.2.p.1">In a system that has potentially more than one ICE agent, it's important that connectivity checks from any given ICE agent cannot be blocked or starved by other ICE agents.  It is also important that an attacker is unable to circumvent any limits by instantiating multiple ICE agents.  </p>
<p id="rfc.section.3.2.p.2">To that end, a single pacing timer is maintained globally whenever multiple ICE agents are operated.  Each time the pacing timer fires, the global context selects ICE agents in a round-robin fashion.  In addition to ensuring a global rate limit, this selection method ensures that no single ICE agent is completely starved.  </p>
<p id="rfc.section.3.2.p.3">In a shared context, ICE agents do not stop or start the pacing timer unless they are the first or last ICE agent to be active.  The first ICE agent to commence checking starts the global timer, the last ICE agent to cancel the timer causes the global timer to be cancelled.  At all other instances, "starting" the pacing timer for an ICE agent simply adds the ICE agent to the set of agents that can be selected; "stopping" the pacing timer removes the ICE agent from the set of ICE agents that are in consideration.  </p>
<p id="rfc.section.3.2.p.4">A global pacing timer causes each individual ICE agent to execute checks more slowly than a lone ICE agent would.  Where there are many candidate pairs to test, this could have a negative impact on the synchronization of checks between peers.  Poor check synchronization can have a negative impact on success rates.  Peers with asymmetric contention can have lower priority candidate pairs started on the less contended peer long before the contended peer is able to commence checking, which can result in those checks failing.  </p>
<p id="rfc.section.3.2.p.5">Several measures are suggested for mitigating the impact of contention: artificial contention, origin-first distribution, inter-agent candidate pair freezing, and delayed start.  However, it is important to note that similar artificial constraints have classically been quickly circumvented on the web if they have overly negative performance consequences.  </p>
<h1 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#artificial-contention" id="artificial-contention">Introducing Artificial Contention</a></h1>
<p id="rfc.section.3.2.1.p.1">In cases where there is zero contention, artificial contention can be introduced to ensure a certain minimum effective pacing timer.  In effect, this would increase the basic pacing timer from 20ms by a minimum multiple for any single ICE agent.  Artificially contention would result in no checks being sent at all at different phases, spacing genuine connectivity checks.  </p>
<p id="rfc.section.3.2.1.p.2">For instance, contention could be increased to a minimum of 3 ICE agents.  Assuming a 20ms basic interval, the first ICE agent would be able to send connectivity checks every 60ms, as though it were contending with two other ICE agents.  Adding another ICE agent would have no effect on this rate.  It would only be if a fourth ICE agent were added that all ICE agents would be reduced to sending checks at 80ms intervals.  </p>
<p id="rfc.section.3.2.1.p.3">This has the advantage of ensuring that a lightly contended client has the same rate of checking as a client with only a small number of ICE agents so that checks are more likely to be synchronized.  </p>
<h1 id="rfc.section.3.2.2"><a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#origin-first-rr" id="origin-first-rr">Origin-First Round-Robin</a></h1>
<p id="rfc.section.3.2.2.p.1">In a system such as a browser, there are potentially competing interests sharing the same limited resources.  In this type of context, each competing user - in the browser, this is an <a href="#RFC6454">origin</a> <cite title="NONE">[RFC6454]</cite> - can first be selected using a round-robin or similar allocation scheme.  </p>
<p id="rfc.section.3.2.2.p.2">Thus, as a first step, selection is performed from the set origins that have an active ICE agent.  Once an origin is selected, agents are selected from within that origin.  This ensures that no single origin can receive more than a proportional share of the access to connectivity checking.  </p>
<p id="rfc.section.3.2.2.p.3">This is particularly important if multiple users (or origins) are each able to create multiple ICE agents.  Selecting based on users first prevents a single origin from monopolizing access to connectivity checks.  </p>
<h1 id="rfc.section.3.2.3"><a href="#rfc.section.3.2.3">3.2.3.</a> <a href="#inter-agent-freezing" id="inter-agent-freezing">Inter-Agent Candidate Pair Freezing</a></h1>
<p id="rfc.section.3.2.3.p.1">In some cases, it might be necessary to instantiate multiple ICE agents from the same application, between the same two peers.  An ICE agent MAY place candidate pairs in the "Frozen" state based on candidate pairs with the same foundation being "Waiting" or "In-Progress" on another ICE agent.  This reduces the overall demand for connectivity checks without any significant negative effect on the chances that ICE succeeds.  </p>
<p id="rfc.section.3.2.3.p.2">In the browser context, information about the success of connectivity checks cannot leak between different domains.  This could allow information about activities on another tab to be leaked, violating the origin security model of the browser.  Thus, any inter-agent freezing logic MUST be constrained to ICE agents that operate in the same origin.  </p>
<h1 id="rfc.section.3.2.4"><a href="#rfc.section.3.2.4">3.2.4.</a> <a href="#delayed-start" id="delayed-start">Delayed ICE Agent Start</a></h1>
<p id="rfc.section.3.2.4.p.1">In cases where there is high contention for access to connectivity checking, it might be preferable to delay the start of connectivity checks for an ICE agent rather than have the effective pacing timer increased.  </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#duration" id="duration">Further Reducing the Impact of Attacks</a></h1>
<p id="rfc.section.4.p.1">A global pacing timer allows a web application to determine whether another domain is currently establishing an ICE transport, simply by observing the pacing of connectivity checks that it requests.  <a href="#artificial-contention">Section 3.2.1</a> describes a method that allows a limited number of ICE agents to operate without being detectable.  </p>
<p id="rfc.section.4.p.2">The algorithm and the measures it describes are based on an assumption that ICE agents are created legitimately.  Even with these measures, it's possible to generate a steady amount of bandwidth toward arbitrary hosts.  The remainder of this section is dedicated to additional measures that might be employed to reduce the ability of malicious users to generate unwanted connectivity checks over time.  </p>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> Bandwidth Rate Limiting</h1>
<p id="rfc.section.4.1.p.1">A measure of the bandwidth generated by connectivity checks can be maintained, on both global and a per-origin basis.  As this number increases, the browser can reduce the rate of connectivity checks.  This reduction might either be gained by increasing the duration of the pacing timer or skipping occasional connectivity checks.  </p>
<p><a href="#ratecalc">Appendix A</a> includes some simple calculations and recommendations on what might be appropriate limits to set on the bandwidth used by connectivity checks.  </p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> Malicious Application Penalties</h1>
<p id="rfc.section.4.2.p.1">An attacker that only wishes to generate traffic is unlikely to provide valid candidates for two reasons: </p>

<ul>
  <li>a successful connectivity check is likely to cause the ICE agent to terminate further checking </li>
  <li>serving connectivity checks requires the dedication of greater resources by the attacker </li>
</ul>

<p> </p>
<p id="rfc.section.4.2.p.2">A long sequence of unsuccessful connectivity checks is therefore a likely indicator for an attack.  An ICE agent could choose to reduce the rate at which connectivity checks are generated for an application that has a large number of failed checks.  </p>
<p id="rfc.section.4.2.p.3">Any measure that penalizes for unsuccessful checks will have to allow for some failures.  Even legitimate uses of ICE can result in significant numbers of failed connectivity checks.  For instance, an implementation that exclusively prioritizes IPv6 over IPv4 on a network with broken IPv6 will legitimately see a large number of failures.  Similarly, if a remote peer is behind a NAT, prior to the commencement of checking by that peer all connectivity checks are likely to be discarded by the NAT.  </p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> Limited Concurrent Access to ICE</h1>
<p id="rfc.section.4.3.p.1">Setting an absolute maximum on the number of ICE agents that can be instantiated could overly constrain legitimate applications that depend on having multiple active sessions.  However, limiting concurrent access to active ICE agents by delaying the start of connectivity checking, as described in <a href="#delayed-start">Section 3.2.4</a> might allow an implementation to reduce the ability of a single origin to generate unwanted connectivity checks.  </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> Negotiating Algorithm Use</h1>
<p id="rfc.section.5.p.1">The algorithm defined in <a href="#algorithm">Section 3</a> could cause some ICE agents to perform checks in a very different order to the order of an unmodified ICE agent.  Failing to coordinate when checks occur reduces the probability that ICE is successful.  </p>
<p id="rfc.section.5.p.2">TODO: Determine whether an ice-options token that enables negotiation of this algorithm is appropriate, or whether something more definitive is required, since an answerer could negotiate an ice-options token away.  Note that WebRTC implementations probably won't be able to accept a session that does not use this algorithm.  </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#security" id="security">Security Considerations</a></h1>
<p id="rfc.section.6.p.1">This entire document is about security.  </p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#ack" id="ack">Acknowledgements</a></h1>
<p id="rfc.section.7.p.1">The bulk of the algorithm described in this document came out of a discussion with Emil Ivov and Pal-Erik Martinsen.  Eric Rescorla and Bernard Aboba provided some feedback regarding the DoS considerations and possible mitigations.  </p>
<h1 id="rfc.references"><a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ivov-mmusic-trickle-ice">[I-D.ivov-mmusic-trickle-ice]</b>
      </td>
      <td class="top"><a>Ivov, E.</a>, <a>Rescorla, E.</a> and <a>J. Uberti</a>, "<a href="http://tools.ietf.org/html/draft-ivov-mmusic-trickle-ice-01">Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol</a>", Internet-Draft draft-ivov-mmusic-trickle-ice-01, March 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5245">[RFC5245]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, "<a href="http://tools.ietf.org/html/rfc5245">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>", RFC 5245, April 2010.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-overview">[I-D.ietf-rtcweb-overview]</b>
      </td>
      <td class="top"><a>Alvestrand, H.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-overview-08">Overview: Real Time Protocols for Brower-based Applications</a>", Internet-Draft draft-ietf-rtcweb-overview-08, September 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-security">[I-D.ietf-rtcweb-security]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-security-05">Security Considerations for WebRTC</a>", Internet-Draft draft-ietf-rtcweb-security-05, July 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-security-arch">[I-D.ietf-rtcweb-security-arch]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-security-arch-07">WebRTC Security Architecture</a>", Internet-Draft draft-ietf-rtcweb-security-arch-07, July 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.martinsen-mmusic-malice">[I-D.martinsen-mmusic-malice]</b>
      </td>
      <td class="top"><a>Penno, R.</a>, <a>Martinsen, P.</a>, <a>Wing, D.</a> and <a>A. Zamfir</a>, "<a href="http://tools.ietf.org/html/draft-martinsen-mmusic-malice-00">Meta-data Attribute signaLling with ICE</a>", Internet-Draft draft-martinsen-mmusic-malice-00, July 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.muthu-behave-consent-freshness">[I-D.muthu-behave-consent-freshness]</b>
      </td>
      <td class="top"><a>Perumal, M.</a>, <a>Wing, D.</a>, <a>R, R.</a> and <a>T. Reddy</a>, "<a href="http://tools.ietf.org/html/draft-muthu-behave-consent-freshness-04">STUN Usage for Consent Freshness</a>", Internet-Draft draft-muthu-behave-consent-freshness-04, July 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3168">[RFC3168]</b>
      </td>
      <td class="top"><a>Ramakrishnan, K.</a>, <a>Floyd, S.</a> and <a>D. Black</a>, "<a href="http://tools.ietf.org/html/rfc3168">The Addition of Explicit Congestion Notification (ECN) to IP</a>", RFC 3168, September 2001.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5389">[RFC5389]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, <a>Mahy, R.</a>, <a>Matthews, P.</a> and <a>D. Wing</a>, "<a href="http://tools.ietf.org/html/rfc5389">Session Traversal Utilities for NAT (STUN)</a>", RFC 5389, October 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5766">[RFC5766]</b>
      </td>
      <td class="top"><a>Mahy, R.</a>, <a>Matthews, P.</a> and <a>J. Rosenberg</a>, "<a href="http://tools.ietf.org/html/rfc5766">Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)</a>", RFC 5766, April 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6454">[RFC6454]</b>
      </td>
      <td class="top"><a>Barth, A.</a>, "<a href="http://tools.ietf.org/html/rfc6454">The Web Origin Concept</a>", RFC 6454, December 2011.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#ratecalc" id="ratecalc">Defining Legitimate Uses of ICE</a></h1>
<p id="rfc.section.A.p.1">Limiting the bandwidth generated by connectivity checks depends on knowing how much ICE could use under normal circumstances.  This ensures any absolute limit doesn't adversely affect a legitimate use of ICE.  </p>
<p id="rfc.section.A.p.2">Any calculation should allow for slightly abnormal configurations that might generate higher than average data rates.  Otherwise, an average might adversely affect legitimate users.  The intent is to avoid having legitimate uses concerned with the limit.  </p>
<h1 id="rfc.appendix.A.1"><a href="#rfc.appendix.A.1">A.1.</a> Candidate Pair Count</h1>
<p id="rfc.section.A.1.p.1">Our sample legitimate user has 2 local network interfaces.  This can result in as many as 14 candidates, 8 of them IPv4 plus 6 IPv6.  Each interface has 1 IPv4 address, an IPv6 address, plus a link-local IPv6 address.  Assuming a different public IPv4 NAT address for each interface and IP version (using either NAT4-4 or NAT6-4 as appropriate) other than the link local addresses, this adds another 4 addresses.  In addition to this, two TURN servers might be contacted by either IPv4 or IPv6, providing 4 more addresses.  </p>
<p id="rfc.section.A.1.p.2">Two peers with this configuration will generate 100 candidate pairs, since only IPv4 candidates are paired with IPv4 candidates.  </p>
<p id="rfc.section.A.1.p.3">Assuming that all candidates are checked once before ICE completes on a second round of checks, there are in excess of 100 connectivity checks sent.  Even at the fastest permitted pacing, this means that ICE completes in at least 2 seconds, plus the round trip time.  </p>
<h1 id="rfc.appendix.A.2"><a href="#rfc.appendix.A.2">A.2.</a> Connectivity Check Size</h1>
<p id="rfc.section.A.2.p.1">The STUN message used for a connectivity check can vary, but making some reasonable assumptions, it is likely to be 149 or 169 bytes on the wire (plus network layer encapsulation).  This makes the following assumptions: </p>

<dl>
  <dt>IP Header:</dt>
  <dd style="margin-left: 8">20 bytes (IPv4) or 40 bytes (IPv6) with no extensions</dd>
  <dt>UDP Header:</dt>
  <dd style="margin-left: 8">8 bytes</dd>
  <dt>STUN Header:</dt>
  <dd style="margin-left: 8">20 bytes</dd>
  <dt>USE-CANDIDATE Attribute:</dt>
  <dd style="margin-left: 8">4 bytes</dd>
  <dt>CONTROLLED or CONTROLLING Attribute:</dt>
  <dd style="margin-left: 8">4 bytes</dd>
  <dt>PRIORITY Attribute:</dt>
  <dd style="margin-left: 8">4 bytes</dd>
  <dt>MESSAGE-INTEGRITY Attribute:</dt>
  <dd style="margin-left: 8">24 bytes</dd>
  <dt>FINGERPRINT Attribute:</dt>
  <dd style="margin-left: 8">8 bytes</dd>
  <dt>USER Attribute:</dt>
  <dd style="margin-left: 8">49 bytes carries two 20 character username fragments</dd>
</dl>

<p> </p>
<h1 id="rfc.appendix.A.3"><a href="#rfc.appendix.A.3">A.3.</a> Rate Calculations</h1>
<p id="rfc.section.A.3.p.1">Assuming a 150 byte connectivity check and a global pacing timer of 20ms, this produces 60kbps at peak (68kpbs for IPv6).  </p>
<p id="rfc.section.A.3.p.2">For 100 candidate pairs, with at most 5 connectivity checks on each pair, this peak could be sustained for 10 seconds by a single ICE agent.  </p>
<p id="rfc.section.A.3.p.3">The question is: is this a tolerable rate? </p>
<h1 id="rfc.appendix.A.4"><a href="#rfc.appendix.A.4">A.4.</a> Comparison: G.711 Audio</h1>
<p id="rfc.section.A.4.p.1">G.711 audio is commonly used without any congestion feedback mechanisms in place - primarily because it is unflexible and unable to scale its network usage in response to congestion signals.  The theory is that it might be acceptable to generate a similar amount of traffic without congestion controls.  </p>
<p id="rfc.section.A.4.p.2">It should be immediately obvious that this theory has a major flaw.  Even though the impact on the network might be similar, G.711 is not sent to an unwilling recipient, whereas no such guarantee can be made for connectivity checks.  </p>
<p id="rfc.section.A.4.p.3">Assuming 80bit integrity on SRTP, no header extensions and no CSRCs, G.711 produces 84kbps.  That would suggest that a single ICE agent with 20ms pacing might be tolerable, at least over short intervals.  </p>
<h1 id="rfc.appendix.A.5"><a href="#rfc.appendix.A.5">A.5.</a> Recommended Rate Limits</h1>
<p id="rfc.section.A.5.p.1">Enforcing a limit of 96kbps would allow for a substantial increase in the size of STUN connectivity check messages without affecting legitimate uses.  </p>
<p id="rfc.section.A.5.p.2">Over a longer interval, this high rate is likely to be unnecessary.  Even with 100 candidate pairs, ICE should complete in between 2 and 5 seconds, especially if candidate pairs are frozen across multiple ICE agents.  Providing a lower limit over a 10 to 20 second interval should further limit the damage.  Enforcing a longer term limit of 48 kilobytes (every 20 seconds or so) would allow for 6 seconds of continuous checking with the size described above, or 4 seconds of checking at the short term rate limit.  </p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> 
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  <span>3210 Porter Drive</span>

	  <span class="vcardline">
		<span class="locality">Palo Alto</span>,  
		<span class="region">CA</span> 
		<span class="code">94304</span>
	  </span>
	  <span class="country-name vcardline">US</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@skype.net">martin.thomson@skype.net</a></span>

  </address>
</div>

</body>
</html>